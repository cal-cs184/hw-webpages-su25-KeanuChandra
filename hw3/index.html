<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<figure>
			<img src="cornell.png" alt="Cornell Boxes with Bunnies" style="width:70%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Part 1: Ray Generation and Scene Intersection</h2>

		<p>For generate_ray,  I converted the coordinates into camera space by normalizing them to [-1,1] and transforming them to camera space by multiplying them by tan(viewing angle / 2). I can then transform my vector into world space by multiplying it with c2w. A ray is then composed of this transformed vector and the world origin.</p>
		<p>In raytrace_pixel I generate num_sample samples using get_sample(). I then generate a ray by offsetting the pixel coords with my sample coords and normalizing.</p>	
		<p>To find if a ray intersects a triangle, I first check where the ray intersects the triangle's plane using the Moller Trumbore Algorithm. I solve for barycentric coordinates with the determinant I derived through the cross product of the ray direction vector and the triangle edge. If this determinant is close to zero this means that the ray is parallel to the triangle. Using intermediate vectors p, q, and t we can find the barycentric coordinates of the triangle, giving us a decision if there is a valid hit and t-value (distance).</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="banana.png" width="400px"/>
				  <figcaption>Banana</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBSpheres.png" width="400px"/>
				  <figcaption>Spheres</figcaption>
				</td>
				  <td style="text-align: center;">
				  <img src="cow.png" width="400px"/>
				  <figcaption>Cow</figcaption>
				</td>
			
			  </tr>
			</table>
				
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		<p>I constructed the BVH by splitting on the longest axis of the bounding box using partition. If the split created a node with no members I simply  arbitrarily split the primitives in half. I continued this recursive logic until all nodes were smaller than the maximum leaf size.</p>

		<h2>Part 3: Direct Illumination</h2>
		<p>The first implementation is the estimate_direct_lighitng_hemispheres. This implementation samples a random direction using sample_f that comes from somewhere on the hemisphere. We convert this sampled local direction into world-space and create a ray that starts from our point and goes in the random direction. If it hits a light source, we get an emission value back which we can use to solve for our point's brightness with the Monte Carlo estimator. We do this a number of times and output the average. </p>
		<p>The second implementation is importance sampling. This time we iterate through all the light sources and trace rays to our point. We check if this light source is not blocked by an object and add the contribution via the Monte Carlo estimator. </p>
			
		<h2>Part 4: Global illuminationg</h2>

		<h2>Part 5: Adaptive Sampling</h2>

		
		
	
		</div>
	</body>
</html>
