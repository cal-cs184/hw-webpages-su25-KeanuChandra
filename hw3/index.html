<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 3 Write-Up</h1>
		<div style="text-align: center;">Names: Keanu Chandra</div>

		<br>

		Link to webpage: <a href="https://cal-cs184.github.io/hw-webpages-su25-KeanuChandra/hw3/index.html">https://cal-cs184.github.io/hw-webpages-su25-KeanuChandra/hw3/index.html</a>
		Link to GitHub repository: <a href="https://github.com/cal-cs184/hw-pathtracer-updated-teamofone">https://github.com/cal-cs184/hw-pathtracer-updated-teamofone</a>
		

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		In this homework I created ray surface intersection algorithms for triangles, spheres, and bounding boxes using the various methods learned in lecture such as Moller-Trumbore and the quadratic sphere-ray intersection method. Then I implemented a bounding volume hierarchy tree, which significantly shortened rendering times by calculating ray intersections through a traversal tree. Next was the implementation of direct illumination from light sources and global illumination from ambient light which used the Monte Carlo estimator and tracking of rays back towards a light source. Finally, adaptive sampling was implemented, which increased sampling rates in areas with high illumination variance.   

		<h2>Part 1: Ray Generation and Scene Intersection</h2>

		<p>For generate_ray,  I converted the coordinates into camera space by normalizing them to [-1,1] and transforming them to camera space by multiplying them by tan(viewing angle / 2). I can then transform my vector into world space by multiplying it with c2w. A ray is then composed of this transformed vector and the world origin.</p>
		<p>In raytrace_pixel I generate num_sample samples using get_sample(). I then generate a ray by offsetting the pixel coords with my sample coords and normalizing.</p>	
		<p>To find if a ray intersects a triangle, I first check where the ray intersects the triangle's plane using the Moller Trumbore Algorithm. I solve for barycentric coordinates with the determinant I derived through the cross product of the ray direction vector and the triangle edge. If this determinant is close to zero this means that the ray is parallel to the triangle. Using intermediate vectors p, q, and t we can find the barycentric coordinates of the triangle, giving us a decision if there is a valid hit and t-value (distance).</p>
		<p>Below are some of my renders</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="mlt.jpg" width="400px"/>
				  <figcaption>Moller Trumbore algorithm I used to check for intersection.</figcaption>
				</td>
			</table>
				
		</div>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="banana.png" width="400px"/>
				  <figcaption>Banana</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBspheres.png" width="400px"/>
				  <figcaption>Spheres</figcaption>
				</td>
				  <td style="text-align: center;">
				  <img src="cow.png" width="400px"/>
				  <figcaption>Cow</figcaption>
				</td>
			
			  </tr>
			</table>
				
		</div>
		
		<h2>Part 2: Bounding Volume Hierarchy</h2>
		<p>I constructed the BVH by splitting on the longest axis of the bounding box using partition. If the split created a node with no members I simply  arbitrarily split the primitives in half. I continued this recursive logic until all nodes were smaller than the maximum leaf size.</p>
		<p>For the cow, without BVH the rendering took 41.5361 seconds at 0.0116 million rays per second. With BVH the cow took only 0.067 seconds at 6.9848 million rays per second. In terms of speed, this is a 600 fold increase showing that BVH was able to exponentially increase our render times. This allowed me to render more complex dae files in seconds as shown below.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="blucy.png" width="400px"/>
				  <figcaption>Blucy</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="max.png" width="400px"/>
				  <figcaption>Mr. Max Planck</figcaption>
				</td>
				  <td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Teapot</figcaption>
				</td>
			
			  </tr>
			</table>
				
		</div>

		<h2>Part 3: Direct Illumination</h2>
		<p>The first implementation is the estimate_direct_lighitng_hemispheres. This implementation samples a random direction using sample_f that comes from somewhere on the hemisphere. We convert this sampled local direction into world-space and create a ray that starts from our point and goes in the random direction. If it hits a light source, we get an emission value back which we can use to solve for our point's brightness with the Monte Carlo estimator. We do this a number of times and output the average. </p>
		<p>The second implementation is importance sampling. This time we iterate through all the light sources and trace rays to our point. We check if this light source is not blocked by an object and add the contribution via the Monte Carlo estimator. </p>

			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_H_16_8_hemisphere.png" width="400px"/>
				  <figcaption>Bunny Uniform Hemisphere</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_H_16_8_importance.png" width="400px"/>
				  <figcaption>Bunny Importance Sampling</figcaption>
				</td>		
			  </tr>
				<tr>
				<td style="text-align: center;">
				  <img src="wall-e_16_8_hemisphere.png" width="400px"/>
				  <figcaption>Wall-e Uniform Hemisphere</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="wall-e_16_8_importance.png" width="400px"/>
				  <figcaption>Wall-e Importance Sampling</figcaption>
				</td>		
			  </tr>
				<tr>
				<td style="text-align: center;">
				  <img src="coil_16_8_hemisphere.png" width="400px"/>
				  <figcaption>Coil Uniform Hemisphere</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="coil_16_8_importance.png" width="400px"/>
				  <figcaption>Coil Importance Sampling</figcaption>
				</td>		
			  </tr>
			</table>
				
		</div>
			<p>In comparison to importance sampling, uniform hemisphere sampling is significantly more grainy. This is because in importance sampling there is a significant amount of randomness involved since rays are being fired off randomly into the hemisphere. Importance sampling, on the other hand, focuses on where incoming light is likely to be coming resulting in significantly less "random noise" that we see in hemisphere sampling." 
			<p>Below are renders of the bunny with importance sampling with different values of light rays.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_1_1.png" width="400px"/>
				  <figcaption>1 light ray</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_1_4.png" width="400px"/>
				  <figcaption>4 light rays</figcaption>
				</td>	
				  <td style="text-align: center;">
				  <img src="CBbunny_1_16.png" width="400px"/>
				  <figcaption>16 light rays</figcaption>
				</td>	
				  <td style="text-align: center;">
				  <img src="CBbunny_1_64.png" width="400px"/>
				  <figcaption>64 light rays</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
			
			
		<h2>Part 4: Global illumination</h2>
		<p>In this part, I implemented multiple light bounces using a recursive algorithm. I first found the one_bounce_radiance which I calculated in the previous part. I then determined the next direction from where light may have arrived using the material's BSDF through sample_f. I recieve the incoming direction and the pdf of that direction. I repeat this process for a ray going in this direction. This recursion is stopped either when I have hit the maximum depth or roll a stopping condition via the coin flip. I then add the indirect lighting with the one-bounce lighting for the final result. </p>
		<p>Below are some images rendered with global illumination</p>	
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_global_1024.png" width="400px"/>
				  <figcaption>Spheres</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="dragon_global_1024.png" width="400px"/>
				  <figcaption>Dragon</figcaption>
				</td>	
				  <td style="text-align: center;">
				  <img src="empty_global_1024.png" width="400px"/>
				  <figcaption>Empty Box</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
			<p>Here is a comparison that shows only direct illumination and only indirect illumination</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="CBbunny_1_1.png" width="400px"/>
				  <figcaption>1 light ray</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="CBbunny_1_4.png" width="400px"/>
				  <figcaption>4 light rays</figcaption>
				</td>	
				  <td style="text-align: center;">
				  <img src="CBbunny_1_16.png" width="400px"/>
				  <figcaption>16 light rays</figcaption>
				</td>	
				  <td style="text-align: center;">
				  <img src="CBbunny_1_64.png" width="400px"/>
				  <figcaption>64 light rays</figcaption>
				</td>	
			  </tr>
			</table>
				
				
		</div>
			<p>Here is a comparison between only direct illumination and only indirect illumination. The indirect illumination is provided by a single extra bounce.</p>
			<p>Below are renders of the bunny with importance sampling with different values of light rays.</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny_direct_1024.png" width="400px"/>
				  <figcaption>ONLY direct lighting</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_indirect_output_1024.png" width="400px"/>
				  <figcaption>ONLY indirect lighting</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
			<p>The next images show the same dae file but without accumulated bounces at different levels of ray depth</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny_noAccum_output_1024_0.png" width="400px"/>
				  <figcaption>0 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_noAccum_output_1024_1.png" width="400px"/>
				  <figcaption>1 bounce</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_indirect_output_1024.png" width="400px"/>
				  <figcaption>2 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_noAccum_output_1024_3.png" width="400px"/>
				  <figcaption>3 bounces</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_noAccum_output_1024_4.png" width="400px"/>
				  <figcaption>4 bounces</figcaption>
				</td>	
				 <td style="text-align: center;">
				  <img src="bunny_noAccum_output_1024_5.png" width="400px"/>
				  <figcaption>5 bounces</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>

		<p>From the second to third bounces of light, there is significantly less intensity of light, but importantly, we can still see light contributions in areas where there are shadows. This softens the shadows using real light physics instead of faking soft edges like rasterization.</p> 

		<p>The next images show the same dae file but with accumulated bounces at different levels of ray depth</p>
			<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_0.png" width="400px"/>
				  <figcaption>0 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_1.png" width="400px"/>
				  <figcaption>1 bounce</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_2.png" width="400px"/>
				  <figcaption>2 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_3.png" width="400px"/>
				  <figcaption>3 bounces</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_4.png" width="400px"/>
				  <figcaption>4 bounces</figcaption>
				</td>	
				 <td style="text-align: center;">
				  <img src="bunny_Accum_output_1024_5.png" width="400px"/>
				  <figcaption>5 bounces</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
		<p>Below is the same dae file but with Russian Roulette rendering with continuation probability set to 0.6</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="bunny_rr_output_1024_0.png" width="400px"/>
				  <figcaption>0 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_rr_output_1024_1.png" width="400px"/>
				  <figcaption>1 bounce</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_rr_output_1024_2.png" width="400px"/>
				  <figcaption>2 bounces</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunny_rr_output_1024_3.png" width="400px"/>
				  <figcaption>3 bounces</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunny_rr_output_1024_4.png" width="400px"/>
				  <figcaption>4 bounces</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
		<p>Finally we have the spheres rendered at differing sample-per-pixel rates</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_spp_1.png" width="400px"/>
				  <figcaption>1 sample per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_spp_2.png" width="400px"/>
				  <figcaption>2 sample per pixele</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="spheres_spp_4.png" width="400px"/>
				  <figcaption>4 sample per pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_spp_64.png" width="400px"/>
				  <figcaption>64 sample per pixel</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="spheres_spp_1024.png" width="400px"/>
				  <figcaption>1024 sample per pixel</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
			
		<h2>Part 5: Adaptive Sampling</h2>
		<p>Adaptive sampling gives more samples to areas with high-variance such as edges while uniform surfaces will get less samples. To implement this we sample in batches. In each of these batches we accumulate illuminance values through s1 and s2. We can then calculate the mean of s1 and variance which is (s2 - (s1^2) / num_samples) / (num_samples - 1). We then calculate I which is the 95 percent confidence interval for the mean. If our confidence interval is less than our tolerance, then we can stop sampling as we have determined the batch to be stable enough. Unfortuantely in my implementation the cieling did not recieve adaptive sampling which I could not debug.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="spheres_adaptive.png" width="400px"/>
				  <figcaption>Spheres with adaptive sampling</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="spheres_adaptive_rate.png" width="400px"/>
				  <figcaption>Sphere rates</figcaption>
				</td>	
			  </tr>
				 <tr>
				<td style="text-align: center;">
				  <img src="bunnyadaptive.png" width="400px"/>
				  <figcaption>Bunny with adaptive sampling</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="bunnyadaptive_rate.png" width="400px"/>
				  <figcaption>Bunny Rates</figcaption>
				</td>	
			  </tr>
			</table>
				
		</div>
		
	
		</div>
	</body>
</html>
