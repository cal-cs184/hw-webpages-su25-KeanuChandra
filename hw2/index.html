<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 2 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<br>
		
		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="teapot.png" alt="Teapot" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per part, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Section I: Bezier Curves and Surfaces</h2>

		<h3>Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
		Casteljau’s algorithm uses LERP in order to recursively find a point on a curve at a given timestep. We process n points by LERPing adjacent points to get n-1 intermediate points. We continue doing this until we are left with one point that lies on our Bezier Curve. I implemented only one step which iterates through all the points except the last and LERPs the current point with the next.

		<p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="teapot.png" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div>

		<h3>Part 2: Bezier surfaces with separable 1D de Casteljau</h3>
		<p>For Bezier surfaces we use the exact same process for evaluating a row vector of points. The only difference is that these points are 3-dimensional. Using our intermediate row points now use Casteljau again to evaluate the point on the Bezier surface.</p>

		<h2>Section II: Triangle Meshes and Half-Edge Data Structure</h2>

		<h3>Part 3: Area-weighted vertex normals</h3>
		<p>Starting at the halfedge of our vertex we are evaluating we find two more points on a triangle, first the vertex of the twin and then the vertex of the next twin. We then cross multiply the edges to get our face normal. To iterate through all surrounding triangles we set the next halfedge to be on another of the edges by making it the next of the twin of the current halfedge. We do this until we return ot our original halfedge.</p>

		<h3>Part 4: Edge flip</h3>
		<p>Edge flip first gets all the relevant half edges, vertices, edges, and faces. I then moved the crossing half edge by changing its vertex and next half edge. I modified its adjacent halfedges to make a legal mesh. I repeated this for the twin of the crossing half edge. I did have an issue while debugging where one of my edges was disappearing but I was able to solve this using check_for on my disappearing edge and clicking on the halfedges to see if they were still attached to the edge.</p>

		<h3>Part 5: Edge split</h3>
		<p>Edge split was a lot more complicated because I had to introduce 3 new edges, two new faces, and 6 new half edges. I created a diagram of my components and then made sure to modify every element using setNeighbors to have the correct neighbors (even if there wasn’t any change). There were two major debugging issues I faced. First, I kept losing an edge due to the fact that I was setting the twin of my bottom edges to the twin of the old bottom edges after they had been modified, leading to them receiving the wrong half-edges for the twin. Second, I was also not modifying these twins to have a changed twin values of the bottom edges not the middle edges.</p>

		<h3>Part 6: Loop subdivision for mesh upsampling</h3>
		<p>Upsample has several loops in order to implement loop subdivision. The first loop computes new positions for the original vertices using the formula provided in the spec. The second loop finds the edge midpoint using a weighted midpoint. The third loop stores the original edges and then the fourth loop splits them. Finally, edges that connect old and new vertices are flipped and positions are updated. </p>
		<p>Using loop subdivision, our cube becomes very asymmetric and loses form. This is because the faces do not have symmetric edges. By splitting each face to make a cross we get a more symmetric result from loop subdividision. </p>

		</div>
	</body>
</html>
